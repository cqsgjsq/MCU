
--------------------------2020.3.13
for input:
low = 0.3 * VDO
high = 0.7 * VDD
hysteresis = 0.1*VDD
--------------------------2020.3.14
Q：低功耗问题（进入低功耗后，暗电流差距1mA多）
A：1.检查进入低功耗流程是否有误？ 2.根据外部电路配置IO口，普通IO口配置为输出低电平
怀疑对象：
低功耗期间时钟用的是LSI，HSE没有关闭？
实验结果：MCU不能选着LSI用做Fmaster，因为option byte默认禁止LSI当作fmaster!

Do：AMU或者halt模式期间给芯片加热，低功耗会下降很多，随着温度上升，低功耗会增大（AMU状态下，LSI受温度影响较大）
1.给功耗差别大PCB交换芯片，看是贴片的问题还是芯片的问题？
2.检查IO口是否真的如预期配置，such as:有些引脚只有OD
3.检查各个外设所消耗电流
4.进入低功耗前检查寄存器value是否如预期？
5.去掉外部电路，check芯片自身功耗
6.理论功耗+外部电路，理论与实际差别是否可接受
7.是否开启WD？

最终原因：芯片内部还有很多IO口,我们只拉低外部能看到的引脚，其实内部还有很多引脚，我们也需要拉低内部引脚，使其处于最低功耗

其实datasheet相关PIN图下面一直都有提示，不过自己确实没看数据手册，在开发前，应该先看MCU基本信息的，有没什么特别注意的事项，如果当初开发前了解了相关事项，就不会浪费起码好几天的开发时间和10块开发板了！

2020.3.16
有时候不能从低功耗唤醒？
我第一反应居然是软件问题？
正确的工程师，应该是先排查电源是否有问题，然后排查MCU的引脚硬件电路，看MCU外部电路是否正常，然后才应该开始排查软件问题，MDZZ。。。

2020.3.17
读取IO口Level时，要配置input float状态，不然会影响读取的IO值！如果配置为输出低电平，MCU内部会有个下拉电阻，该引脚连接外部电路，如果外部电路输出高电平，经过下拉电阻，此时IO引脚读取不准确！

2020.3.24
关于输入捕获，其实很简单，就是连续读取2次PWM的上升沿，TIM计数器会把此时的CNT Value给相应寄存器，当正在处理第一次上升沿的时候（程序还没读取结束），此时第二次上升沿来的时候，此时有个TIMx—>SR2有个相应的OF（over flag），在第一个上升沿后，程序应该while（1==TIMx->SR2）;
为了减少计算，ST有个复位触发模式，在上一个上升沿，CNT变为“0”，这样第二个上升沿的CNT Value就是其PWM周期！
计算占空比的时候，可以用另一个通道来capture它的下降沿，和复位触发模式搭配，这样得到的值就是“1”的占用时间
如果第一个和第二个上升沿间隔超过了TIMx一个最大计数值，可以通过分频的形式，降低计数频率，来延长时间！

对于一些库函数的操作，在编译中，有些警告不能忽略，比如TIMx的PWM输出，如果相关.c文件没有包括声明，就使用该函数，最后烧录进flash，是没有PWM输出的！但是自己写的函数，没有声明，该函数是可以运行的，所以怀疑是IDE工具配置选项的问题！

2020.3.25
关于捕获是用中断还是等待？
使用中断将耗费CPU资源，使用循环等待，就会影响其他模块的执行，而且程序还有卡死的风险！
关于定时器模块的PWM捕获，不能在中断打断点，否则得到的value有点异常，可以利用数组的形式，打印出来，对于上升沿和下降沿的捕获，确保先捕获上升沿，再捕获下降沿，要保持逻辑的连贯性，在上升沿中赋值一个变量step++，然后捕获下降沿的前提条件是step==1，同理捕获完成后step++，又在上升沿判断

2020.3.26
关于芯片自身的低功耗，主要集中在IO口，和外部电路的电流，
不能对所有的IO口都输出为低，demo:CAN module ，T/RX要设置为开漏，开漏比输出低电平更加省电，原因是CAN驱动芯片的影响；

2020.3.27
操作eeprom的时候，要注意MCU的电压
MCU operating voltage（execute code） 2.6V~5.5V  
MCU operating voltage（all mode ,execute write erase） 2.6V~5.5V  
标准programming（1byte，4byte 128byte）time 	Max == 6.6MS
erase Time for 1block（128 bytes）               Max == 3.3Ms
MCU execute code逻辑判断的时候，要特别注意eeprom的操作时间 很重要！

2020.3.28
IAR从debug版本到release版本，其实debug版本里面有很多系统自己添加的仿真代码，所谓的软件仿真调试，就是在程序中添加一些代码，设置一些陷阱，然后在这里打断点，所以debug版本编译出来的烧录文件比release版本大很多
关于release报错的问题，重新设置一下Options...选项的配置，比如用的是什么芯片型号，“C/C++Compiler"的"Preprocessor"里面要重新包含一下头文件路径。

2020.5.7
问题:
1.烧录程序完成。正常电压12V上电仿真工作，缓慢下电压到6.5V CAN通讯关闭，继续下电压到6.3V CAN通讯将恢复，再继续下电到5V左右CAN通讯再次关闭？
（和软件硬件沟通后判定为参考电压不准导致CAN异常恢复）
（一）参考电压不准，导致读取的AD不准，所以6.5V关闭了CAN，在6.3V的时候此时参考电压不是5V，所以此时MCU认为AD值已经达到了CAN开启的A的阀值
（二）也是由于参考电压的原因，在6.5V正常关断CAN，然后再下降到6.3V，此时读取的IO口电平，有可能是高，也有可能是低，所以导致MCU频繁进出低功耗，由于在初始化的时候，CAN默认是开启的，所以在6.3V，CAN依然可以通讯
（三）同时存在以上2种原因
Debug:1.上电初始化默认是欠压模式关闭CAN，满足电压条件后才发送CAN
2.kl15外接高电压，此时可以超级简单判断是频繁进出低功耗问题还是算法问题。。。。妈的，怎么才想到
3.更改硬件，提高KL15的电阻，增加分压比例，此时KL15的IO口不会有处于那种undefined状态！

终极原因:还是频繁进出低功耗原因。。。

2.0V缓慢升起电压，6.4V左右CAN 短暂恢复通讯后关闭，继续升高电压到7V左右CAN通讯恢复
参考电压原因可能导致算法问题或者进出低功耗                                              
3.3V左右缓慢升起电压，6.4V左右CAN 恢复通讯，继续升高电压不会有中断的现象。
MCU工作电压为(2.6~5.5)V，此时由于参考电压原因，KL5一直是ON，所以CAN一直没关闭，未验证
以上主要是电压的阀值，IO口处于undefined状态！

要确定MCU处于那个状态，可以在MCU种输出PWM波形或者高低电平，调节高低电平，或者不同占空比！！！！！！！！！！！！！！
还是推荐PWM波形，因为MCU不处于工作状态，没配置IO口，肯定不会输出PW波形，
不同MCU的IO口默认不同，powerPC就是weak pull-up，所以很难确定！
